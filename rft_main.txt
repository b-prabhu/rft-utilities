/**
 * Resource Forecast Tool â€” Office Script for Excel on the Web
 * Updated: 2025-09-22
 *
 * RM Rules:
 *  - EDNS (Exclusive-DoNotShare): Primary-only. Entire monthly share must be assigned within the month (split over days) or it lapses.
 *  - ES1 (Exclusive-ShareOne): Exactly one assignee per month. Prefer primary; if primary has ZERO workable capacity for the month,
 *    reassign the ENTIRE month to exactly one alternate. Entire monthly share must be assigned in-month (split over days) or it lapses.
 * Ordering:
 *  - For each month, use all RM (EDNS, then ES1) first. Standard PSP runs only after RM pools are zero for that month. PSP does not lapse.
 */

/////////////////////// Types & Utils ///////////////////////

interface Dict<T> { [key: string]: T }

type StatusType = "Active" | "Inactive";
type DistMethod = "Standard" | "Recurring Monthly";
type AssignType = "Primary-ShareProportion" | "Exclusive-ShareOne" | "Exclusive-DoNotShare";

type Cell = string | number | boolean | null;
type Row = Cell[];

type Config = {
  dailyHours: number | null;
  forecastStart: Date | null;
  forecastEnd: Date | null;
  minMonthlyShare?: number;
  minWeeklyShare?: number;
  eolWindowDays?: number;
  eolMaxBoost?: number;
};

type ProjectRow = {
  key: string; id: string; name: string; pm: string; desc: string;
  total: number; prevUsed: number; remaining: number;
  start: Date; end: Date; status: StatusType;
  distMethod: DistMethod; primaryId: string; primaryName: string; assignType: AssignType;
};

type ResourceRow = {
  id: string; name: string; role: string; start: Date; end: Date; status: StatusType;
};

type ResAlloc = { ResourceId: string; ResourceName: string; ProjectKey: string; ProjectId: string; ProjectName: string; Date: string; Hours: number; Notes: string; };
type ProAlloc = { ProjectKey: string; ProjectId: string; ProjectName: string; ProjectManager: string; Date: string; Hours: number; Notes: string; };

type ProjectRemaining = { totalRemaining: number; monthlyRemaining: Dict<number> };
type Cand = { p: ProjectRow; left: number; prioKey: [number, number, number, number] };

// NEW: structured view of unavailability with Reasons (for pseudo-project outputs)
type UnavailReasonEvent = { ResourceId: string; Date: string; Hours: number; Reason: string };

let resourcesById: Dict<ResourceRow> = {};
const QUANTUM = 0.5;
const EPS = 1e-6;
const MAX_STD_DAILY = 2.0;

const EXPECTED: { [tableName: string]: string[] } = {
  Configurations: ["ConfigId", "Name", "Value", "Status", "Description"],
  Calendar: ["Date", "Year", "Month", "AvailableHours"],
  Projects: ["ProjectKey", "ProjectId", "ProjectName", "Description", "Project Manager", "TotalHours", "PreviouslyUsedHours", "RemainingHours", "StartDate", "EndDate", "Status", "Distribution Method", "PrimaryResourceId", "PrimaryResourceName", "PrimaryResourceAssignmentType"],
  Resources: ["ResourceId", "ResourceName", "Role", "StartDate", "EndDate", "Status"],
  ResourceAvailability: ["ResourceId", "Date", "UnavailableHours", "Reason"]
};

function dateOnly(d: Date): Date { return new Date(d.getFullYear(), d.getMonth(), d.getDate()); }
function quantizeDown(x: number): number { const q = Math.floor(x / QUANTUM) * QUANTUM; return q >= QUANTUM ? q : 0; }
function asString(v: unknown): string { return v == null ? "" : String(v).trim(); }
function asNumber(v: unknown): number | null { if (v == null || v === "") return null; if (typeof v === "number" && !isNaN(v)) return v; const n = Number(v as string | number); return isNaN(n) ? null : n; }
function asDate(v: unknown): Date | null {
  if (v instanceof Date) return isNaN(v.getTime()) ? null : dateOnly(v);
  if (typeof v === "number" && isFinite(v)) { const d = new Date(1899, 11, 30); d.setDate(d.getDate() + Math.floor(v)); return dateOnly(d); }
  if (typeof v === "string") {
    const s = v.trim(); if (!s) return null;
    const iso = s.match(/^(\d{4})[-\/](\d{2})[-\/](\d{2})$/);
    if (iso) { const d1 = new Date(Number(iso[1]), Number(iso[2]) - 1, Number(iso[3])); return isNaN(d1.getTime()) ? null : dateOnly(d1); }
    if (/^\d+(\.\d+)?$/.test(s)) { const n = Number(s); const d2 = new Date(1899, 11, 30); d2.setDate(d2.getDate() + Math.floor(n)); return dateOnly(d2); }
    const d3 = new Date(s); return isNaN(d3.getTime()) ? null : dateOnly(d3);
  }
  return null;
}
function toStatus(v: string): StatusType { return v === "Active" ? "Active" : "Inactive"; }
function toDist(v: string): DistMethod { return v === "Recurring Monthly" ? "Recurring Monthly" : "Standard"; }
function toAssign(v: string): AssignType { if (v === "Exclusive-ShareOne") return "Exclusive-ShareOne"; if (v === "Exclusive-DoNotShare") return "Exclusive-DoNotShare"; return "Primary-ShareProportion"; }
function fmtYMD(d: Date): string { return `${d.getFullYear()}-${String(d.getMonth() + 1).padStart(2, "0")}-${String(d.getDate()).padStart(2, "0")}`; }
function yyyymm(d: Date): string { return `${d.getFullYear()}-${String(d.getMonth() + 1).padStart(2, "0")}`; }
function mmdd(d: Date): string { return `${String(d.getMonth() + 1).padStart(2, "0")}/${String(d.getDate()).padStart(2, "0")}`; }
function firstOfMonth(d: Date): Date { return new Date(d.getFullYear(), d.getMonth(), 1); }
function lastOfMonth(d: Date): Date { return new Date(d.getFullYear(), d.getMonth() + 1, 0); }
function cloneDate(d: Date): Date { return new Date(d.getFullYear(), d.getMonth(), d.getDate()); }
function overlaps(aStart: Date, aEnd: Date, bStart: Date, bEnd: Date): boolean { return !(aEnd.getTime() < bStart.getTime() || aStart.getTime() > bEnd.getTime()); }
function isBetween(d: Date, start: Date, end: Date): boolean { const t = d.getTime(); return t >= start.getTime() && t <= end.getTime(); }
function rangeDays(start: Date, end: Date): Date[] { const out: Date[] = []; const cur = cloneDate(start); while (cur.getTime() <= end.getTime()) { out.push(new Date(cur)); cur.setDate(cur.getDate() + 1); } return out; }
function monthKey(d: Date): string { return `${d.getFullYear()}-${String(d.getMonth() + 1).padStart(2, "0")}`; }
function weekKey(d: Date): string {
  const tmp = new Date(Date.UTC(d.getFullYear(), d.getMonth(), d.getDate()));
  const day = (tmp.getUTCDay() + 6) % 7;
  tmp.setUTCDate(tmp.getUTCDate() - day + 3);
  const wk1 = new Date(Date.UTC(tmp.getUTCFullYear(), 0, 4));
  const week = 1 + Math.round(((tmp.getTime() - wk1.getTime()) / 86400000 - 3) / 7);
  return `${tmp.getUTCFullYear()}-W${String(week).padStart(2, "0")}`;
}
function sanitizeSheetNameRaw(name: string): string {
  const invalid = /[\\\/\?\*\:\[\]]/g;
  let clean = name.replace(invalid, "").trim();
  if (clean.length === 0) clean = "Sheet";
  if (clean.length > 31) clean = clean.slice(0, 31);
  return clean;
}

function ensureSheet(workbook: ExcelScript.Workbook, name: string, clear = false): ExcelScript.Worksheet {
  let ws: ExcelScript.Worksheet | undefined = workbook.getWorksheet(name);
  if (!ws) ws = workbook.addWorksheet(name);
  if (clear) ws.getUsedRange()?.clear(ExcelScript.ClearApplyTo.all);
  return ws;
}

function safeDeleteSheet(workbook: ExcelScript.Workbook, name: string): void {
  const ws: ExcelScript.Worksheet | undefined = workbook.getWorksheet(name);
  if (ws) ws.delete();
}

function formatHeader(r: ExcelScript.Range): void {
  const fmt = r.getFormat();
  fmt.getFill().setColor("#D9E1F2");
  fmt.getFont().setBold(true);
}

/////////////////////// Main ///////////////////////

function main(workbook: ExcelScript.Workbook): void {
  safeDeleteSheet(workbook, "ValidationErrors");

  // Validate tables
  const errors: string[] = [];
  const tables = getTablesByName(workbook);
  Object.keys(EXPECTED).forEach(n => { if (!tables[n]) errors.push(`Missing required table: ${n}`); });
  Object.entries(EXPECTED).forEach(([tName, cols]) => {
    const t = tables[tName]; if (!t) return;
    const headers = t.getHeaderRowRange().getValues()[0].map(h => String(h).trim());
    cols.forEach(c => { if (!headers.includes(c)) errors.push(`Table "${tName}" missing column "${c}". Found: [${headers.join(", ")}]`); });
  });
  if (errors.length) { writeValidationErrors(workbook, errors); return; }

  // Config
  const config = readConfigurations(tables.Configurations);
  const dailyHours = config.dailyHours;
  const forecastStart = config.forecastStart!;
  const forecastEnd = config.forecastEnd!;
  if (!forecastStart || !forecastEnd) { writeValidationErrors(workbook, [`Configurations must include valid dates.`]); return; }
  if (forecastStart.getTime() > forecastEnd.getTime()) { writeValidationErrors(workbook, [`Forecast Start Date must be <= End Date.`]); return; }
  if (dailyHours == null || dailyHours <= 0) { writeValidationErrors(workbook, [`Daily Available Hours must be positive.`]); return; }

  // Inputs
  const cal = readCalendar(tables.Calendar, forecastStart, forecastEnd, errors);
  const projects = readProjects(tables.Projects, forecastStart, forecastEnd, errors);
  const resources = readResources(tables.Resources, forecastStart, forecastEnd, errors);
  // NEW: get unavailability both as hours map and reason events
  const ua = readResourceUnavailability(tables.ResourceAvailability);
  const unavail: Dict<number> = ua.hours;
  const unavailReasonEvents: UnavailReasonEvent[] = ua.byReason;

  for (let i = 0; i < projects.length; i++) {
    const p = projects[i];
    if (p.primaryId && !resourcesById[p.primaryId]) errors.push(`PrimaryResourceId "${p.primaryId}" not found for project ${p.id} (${p.name}).`);
    if (!p.primaryId && (p.assignType === "Exclusive-DoNotShare" || p.assignType === "Exclusive-ShareOne" || p.assignType === "Primary-ShareProportion")) {
      errors.push(`Missing PrimaryResourceId for project ${p.id} (${p.name}) with assignment type ${p.assignType}.`);
    }
  }
  if (errors.length) { writeValidationErrors(workbook, errors); return; }

  /////////////////////// Availability ///////////////////////

  const dateKeys: string[] = [];
  const perDayAvail: Dict<Dict<number>> = {};
  const daysAll = rangeDays(forecastStart, forecastEnd);

  for (let i = 0; i < daysAll.length; i++) {
    const d = daysAll[i];
    const key = fmtYMD(d);
    dateKeys.push(key);
    const calHours = cal[key] ?? dailyHours!;
    const dayAvail: Dict<number> = {};
    for (let j = 0; j < resources.length; j++) {
      const r = resources[j];
      if (!isBetween(d, r.start, r.end)) continue;
      const dayBase = Math.min(calHours, dailyHours!);
      const uaHours = unavail[`${r.id}|${key}`] ?? 0;
      const avail = Math.max(0, dayBase - uaHours);
      dayAvail[r.id] = avail;
    }
    perDayAvail[key] = dayAvail;
  }

  const totalAvailByDate: Dict<number> = {};
  for (let i = 0; i < dateKeys.length; i++) {
    const dk = dateKeys[i];
    const ids = Object.keys(perDayAvail[dk] ?? {});
    let s = 0; for (let j = 0; j < ids.length; j++) s += perDayAvail[dk][ids[j]] ?? 0;
    totalAvailByDate[dk] = s;
  }

  /////////////////////// Pools ///////////////////////

  const projectPools: Dict<ProjectRemaining> = {};
  for (let i = 0; i < projects.length; i++) {
    const p = projects[i];
    projectPools[p.key] = { totalRemaining: (p.distMethod === "Recurring Monthly") ? 0 : p.remaining, monthlyRemaining: {} };
  }

  const monthsBetween = (aStart: Date, aEnd: Date): Date[] => {
    let m = new Date(aStart.getFullYear(), aStart.getMonth(), 1);
    const e = new Date(aEnd.getFullYear(), aEnd.getMonth(), 1);
    const out: Date[] = [];
    while (m.getTime() <= e.getTime()) { out.push(new Date(m)); m = new Date(m.getFullYear(), m.getMonth() + 1, 1); }
    return out;
  };
  const monthsOverlap = (mStart: Date, pStart: Date, pEnd: Date): boolean => {
    const mEnd = lastOfMonth(mStart);
    return !(mEnd.getTime() < pStart.getTime() || mStart.getTime() > pEnd.getTime());
  };

  // Build monthlyRemaining for RM and soft targets for Standard
  const softMonthTarget: Dict<Dict<number>> = {};
  for (let ip = 0; ip < projects.length; ip++) {
    const p = projects[ip];
    softMonthTarget[p.key] = {};
    const months = monthsBetween(forecastStart, forecastEnd).filter(ms => monthsOverlap(ms, p.start, p.end));
    if (months.length === 0) continue;

    if (p.distMethod === "Recurring Monthly") {
      const monthlyShare = quantizeDown(p.remaining);
      if (monthlyShare < QUANTUM) continue;
      for (let i = 0; i < months.length; i++) {
        const mk = monthKey(months[i]);
        projectPools[p.key].monthlyRemaining[mk] = monthlyShare; // lapsing month pool
        softMonthTarget[p.key][mk] = monthlyShare;
      }
    } else {
      const total = quantizeDown(p.remaining);
      if (total < QUANTUM) continue;
      const base = quantizeDown(total / months.length);
      let used = base * months.length;
      let rem = quantizeDown(total - used);
      for (let i = 0; i < months.length; i++) {
        const mk = monthKey(months[i]);
        let share = base;
        if (rem >= QUANTUM) { share += QUANTUM; rem = quantizeDown(rem - QUANTUM); }
        softMonthTarget[p.key][mk] = share;
      }
    }
  }

  // Daily soft cap per project-day
  const dailySoftCap: Dict<Dict<number>> = {};
  for (let ip = 0; ip < projects.length; ip++) {
    const p = projects[ip];
    dailySoftCap[p.key] = {};
    const months = monthsBetween(forecastStart, forecastEnd).filter(ms => monthsOverlap(ms, p.start, p.end));
    for (let im = 0; im < months.length; im++) {
      const ms = months[im];
      const mk = monthKey(ms);
      const targetMonth = (p.distMethod === "Recurring Monthly")
        ? (projectPools[p.key].monthlyRemaining[mk] ?? 0)
        : (softMonthTarget[p.key][mk] ?? 0);

      const mStart = firstOfMonth(ms), mEnd = lastOfMonth(ms);
      const days = rangeDays(mStart, mEnd)
        .filter(d => isBetween(d, p.start, p.end) && isBetween(d, forecastStart, forecastEnd))
        .filter(d => (totalAvailByDate[fmtYMD(d)] ?? 0) >= QUANTUM);

      if (days.length === 0 || targetMonth < QUANTUM) continue;

      const basePerDay = quantizeDown(targetMonth / days.length);
      const usedBase = basePerDay * days.length;
      let rem = quantizeDown(targetMonth - usedBase);

      for (let i = 0; i < days.length; i++) {
        const dk = fmtYMD(days[i]);
        let cap = basePerDay;
        if (rem >= QUANTUM) { cap += QUANTUM; rem = quantizeDown(rem - QUANTUM); }
        if (p.distMethod === "Standard") cap = Math.min(cap, MAX_STD_DAILY);
        dailySoftCap[p.key][dk] = cap;
      }
    }
  }

  /////////////////////// Accumulators ///////////////////////

  const monthAlloc: Dict<Dict<number>> = {};
  const weekAlloc: Dict<Dict<number>> = {};
  for (let i = 0; i < projects.length; i++) { monthAlloc[projects[i].key] = {}; weekAlloc[projects[i].key] = {}; }

  const resAlloc: ResAlloc[] = [];
  const proAlloc: ProAlloc[] = [];
  const assignedPerDay: Dict<Dict<number>> = {};
  const projDayAssigned: Dict<Dict<number>> = {};
  const dateKeysAll = rangeDays(forecastStart, forecastEnd).map(d => fmtYMD(d));
  for (let i = 0; i < dateKeysAll.length; i++) assignedPerDay[dateKeysAll[i]] = {};
  for (let ip = 0; ip < projects.length; ip++) projDayAssigned[projects[ip].key] = {};
  const getAssignedMap = (dk: string): Dict<number> => { if (!assignedPerDay[dk]) assignedPerDay[dk] = {}; return assignedPerDay[dk]; };

  const MIN_MONTHLY_SHARE = config.minMonthlyShare ?? QUANTUM;
  const MIN_WEEKLY_SHARE = config.minWeeklyShare ?? QUANTUM;
  const EOL_WINDOW_DAYS = config.eolWindowDays ?? 21;
  const EOL_MAX_BOOST = config.eolMaxBoost ?? 3;

  /////////////////////// Helpers ///////////////////////

  const pushAlloc = (p: ProjectRow, r: ResourceRow, d: Date, grant: number, note: string): void => {
    const dk = fmtYMD(d);
    const mk = monthKey(d);
    const wk = weekKey(d);
    const map = getAssignedMap(dk);
    map[r.id] = (map[r.id] ?? 0) + grant;
    projDayAssigned[p.key][dk] = (projDayAssigned[p.key][dk] ?? 0) + grant;

    resAlloc.push({ ResourceId: r.id, ResourceName: r.name, ProjectKey: p.key, ProjectId: p.id, ProjectName: p.name, Date: dk, Hours: grant, Notes: note });
    proAlloc.push({ ProjectKey: p.key, ProjectId: p.id, ProjectName: p.name, ProjectManager: p.pm, Date: dk, Hours: grant, Notes: note });

    monthAlloc[p.key][mk] = (monthAlloc[p.key][mk] ?? 0) + grant;
    weekAlloc[p.key][wk] = (weekAlloc[p.key][wk] ?? 0) + grant;
  };

  const assignHours = (p: ProjectRow, r: ResourceRow, d: Date, hoursRequested: number, note: string, ignoreSoftCap?: boolean): number => {
    if (hoursRequested <= 0) return 0;
    if (p.assignType === "Exclusive-DoNotShare" && r.id !== p.primaryId) return 0;
    if (!isBetween(d, forecastStart, forecastEnd)) return 0;

    const dk = fmtYMD(d);
    const mk = monthKey(d);

    const dayCap = (perDayAvail[dk]?.[r.id] ?? 0);
    const already = getAssignedMap(dk)[r.id] ?? 0;
    let room = Math.max(0, dayCap - already);
    if (room < QUANTUM) return 0;

    if (!ignoreSoftCap) {
      const cap = dailySoftCap[p.key]?.[dk];
      if (cap !== undefined) {
        const used = projDayAssigned[p.key][dk] ?? 0;
        const leftCap = Math.max(0, cap - used);
        if (leftCap < QUANTUM) return 0;
        room = Math.min(room, leftCap);
      }
    }

    const pools = projectPools[p.key];
    let poolRemain = (p.distMethod === "Recurring Monthly") ? (pools.monthlyRemaining[mk] ?? 0) : pools.totalRemaining;
    if (poolRemain < QUANTUM) return 0;

    let grant = Math.min(hoursRequested, room, poolRemain);
    grant = quantizeDown(grant);
    if (grant < QUANTUM) return 0;

    if (p.distMethod === "Recurring Monthly") projectPools[p.key].monthlyRemaining[mk] = (pools.monthlyRemaining[mk] ?? 0) - grant;
    else projectPools[p.key].totalRemaining = pools.totalRemaining - grant;

    pushAlloc(p, r, d, grant, note);
    return grant;
  };

  const anyWorkingDayForResourceInMonth = (r: ResourceRow, monthAnyDay: Date, p: ProjectRow): boolean => {
    const days = rangeDays(firstOfMonth(monthAnyDay), lastOfMonth(monthAnyDay));
    for (let i = 0; i < days.length; i++) {
      const d = days[i];
      if (isBetween(d, r.start, r.end) && isBetween(d, p.start, p.end) && isBetween(d, forecastStart, forecastEnd)) return true;
    }
    return false;
  };

  const firstWorkingDayForResourceInMonth = (r: ResourceRow, monthAnyDay: Date): Date | null => {
    const start = firstOfMonth(monthAnyDay), end = lastOfMonth(monthAnyDay), days = rangeDays(start, end);
    for (let i = 0; i < days.length; i++) {
      const d = days[i];
      if (!isBetween(d, forecastStart, forecastEnd)) continue;
      if (!isBetween(d, r.start, r.end)) continue;
      const dk = fmtYMD(d);
      const room = Math.max(0, (perDayAvail[dk]?.[r.id] ?? 0) - (getAssignedMap(dk)[r.id] ?? 0));
      if (room >= QUANTUM) return d;
    }
    return null;
  };

  const daysToEnd = (p: ProjectRow, d: Date): number => Math.floor((p.end.getTime() - d.getTime()) / 86400000);
  const eolBoost = (p: ProjectRow, d: Date): number => {
    const rem = daysToEnd(p, d);
    if (rem > (config.eolWindowDays ?? 21)) return 1;
    const EOL_WINDOW = config.eolWindowDays ?? 21;
    const EOL_MAX = config.eolMaxBoost ?? 3;
    const frac = Math.max(0, (EOL_WINDOW - Math.max(0, rem)) / Math.max(1, EOL_WINDOW));
    return 1 + (EOL_MAX - 1) * frac;
  };

  /////////////////////// ES1 single-assignee cache ///////////////////////

  const es1AssigneeByMonth: Dict<string> = {}; // key: ProjectKey|YYYY-MM -> ResourceId

  const primaryHasAnyWorkableDayInMonth = (p: ProjectRow, mStart: Date): boolean => {
    const primary = p.primaryId ? resourcesById[p.primaryId] : undefined;
    if (!primary) return false;
    const days = rangeDays(mStart, lastOfMonth(mStart));
    for (let i = 0; i < days.length; i++) {
      const d = days[i];
      if (!isBetween(d, forecastStart, forecastEnd) || !isBetween(d, p.start, p.end) || !isBetween(d, primary.start, primary.end)) continue;
      const dk = fmtYMD(d);
      const room = Math.max(0, (perDayAvail[dk]?.[primary.id] ?? 0) - (getAssignedMap(dk)[primary.id] ?? 0));
      if (room >= QUANTUM) return true;
    }
    return false;
  };

  const getEs1Assignee = (p: ProjectRow, mStart: Date): ResourceRow | null => {
    const mk = monthKey(mStart);
    const key = `${p.key}|${mk}`;
    const cached = es1AssigneeByMonth[key];
    if (cached) return resourcesById[cached] ?? null;

    if (primaryHasAnyWorkableDayInMonth(p, mStart)) {
      es1AssigneeByMonth[key] = p.primaryId;
      return resourcesById[p.primaryId] ?? null;
    }

    // choose ONE alternate (least-loaded in month) with any workable day
    const monthDays = rangeDays(mStart, lastOfMonth(mStart));
    const monthResTotals: Dict<number> = {};
    for (let di = 0; di < monthDays.length; di++) {
      const dk = fmtYMD(monthDays[di]);
      const ids = Object.keys(perDayAvail[dk] ?? {});
      for (let j = 0; j < ids.length; j++) {
        const rid = ids[j];
        monthResTotals[rid] = (monthResTotals[rid] ?? 0) + (assignedPerDay[dk]?.[rid] ?? 0);
      }
    }
    const candidate = resources
      .filter(r => anyWorkingDayForResourceInMonth(r, mStart, p))
      .sort((a, b) => (monthResTotals[a.id] ?? 0) - (monthResTotals[b.id] ?? 0))[0];

    if (!candidate) return null;
    es1AssigneeByMonth[key] = candidate.id;
    return candidate;
  };

  /////////////////////// RM Month Passes (EDNS, then ES1) â€” FULL MONTH FILL ///////////////////////

  const monthsSeq = monthsBetween(forecastStart, forecastEnd);

  // A) RM EDNS
  for (let im = 0; im < monthsSeq.length; im++) {
    const mStart = monthsSeq[im];
    const mk = monthKey(mStart);
    const mDays = rangeDays(mStart, lastOfMonth(mStart));
    const rmEdns = projects.filter(p =>
      p.distMethod === "Recurring Monthly" && p.assignType === "Exclusive-DoNotShare" && monthsOverlap(mStart, p.start, p.end)
    );
    for (let i = 0; i < rmEdns.length; i++) {
      const p = rmEdns[i];
      const primary = p.primaryId ? resourcesById[p.primaryId] : undefined;
      if (!primary) continue;

      if (!primaryHasAnyWorkableDayInMonth(p, mStart)) continue;

      let left = quantizeDown(projectPools[p.key].monthlyRemaining[mk] ?? 0);
      if (left < QUANTUM) continue;

      for (let idy = 0; idy < mDays.length && left >= QUANTUM; idy++) {
        const d = mDays[idy];
        if (!isBetween(d, p.start, p.end) || !isBetween(d, primary.start, primary.end) || !isBetween(d, forecastStart, forecastEnd)) continue;
        const given = assignHours(p, primary, d, left, "RM EDNS (month fill)", /*ignoreSoftCap*/ true);
        left = quantizeDown(left - given);
      }
    }
  }

  // B) RM ES1
  for (let im = 0; im < monthsSeq.length; im++) {
    const mStart = monthsSeq[im];
    const mk = monthKey(mStart);
    const mDays = rangeDays(mStart, lastOfMonth(mStart));
    const rmEs1 = projects.filter(p =>
      p.distMethod === "Recurring Monthly" && p.assignType === "Exclusive-ShareOne" && monthsOverlap(mStart, p.start, p.end)
    );
    for (let i = 0; i < rmEs1.length; i++) {
      const p = rmEs1[i];
      const assignee = getEs1Assignee(p, mStart);
      if (!assignee) continue;

      let left = quantizeDown(projectPools[p.key].monthlyRemaining[mk] ?? 0);
      if (left < QUANTUM) continue;

      for (let idy = 0; idy < mDays.length && left >= QUANTUM; idy++) {
        const d = mDays[idy];
        if (!isBetween(d, p.start, p.end) || !isBetween(d, assignee.start, assignee.end) || !isBetween(d, forecastStart, forecastEnd)) continue;
        const given = assignHours(p, assignee, d, left, (assignee.id === p.primaryId) ? "RM ES1 (primary, month fill)" : "RM ES1 (alt, month fill)", /*ignoreSoftCap*/ true);
        left = quantizeDown(left - given);
      }
    }
  }

  /////////////////////// Standard seeding (kept minimal) ///////////////////////

  // Standard EDNS
  monthsSeq.forEach((mStart) => {
    const listA = projects.filter(pp => pp.assignType === "Exclusive-DoNotShare" && pp.distMethod === "Standard");
    listA.forEach((p) => {
      if (!monthsOverlap(mStart, p.start, p.end)) return;
      const primary = resourcesById[p.primaryId]; if (!primary) return;
      const start = firstOfMonth(mStart), end = lastOfMonth(mStart);
      const days = rangeDays(start, end);
      for (let idy = 0; idy < days.length; idy++) {
        const d = days[idy];
        if (!isBetween(d, forecastStart, forecastEnd)) continue;
        if (!isBetween(d, p.start, p.end) || !isBetween(d, primary.start, primary.end)) continue;
        const ask = quantizeDown(projectPools[p.key].totalRemaining);
        if (ask >= QUANTUM) assignHours(p, primary, d, ask, "EDNS Standard (first available day)", true);
        break;
      }
    });
  });

  // Standard ES1
  monthsSeq.forEach((mStart) => {
    const mEnd = lastOfMonth(mStart);
    const monthDays = rangeDays(mStart, mEnd);
    const listB = projects.filter(pp => pp.assignType === "Exclusive-ShareOne" && pp.distMethod === "Standard");
    listB.forEach((p) => {
      if (!monthsOverlap(mStart, p.start, p.end)) return;
      const primary = resourcesById[p.primaryId];
      let assigned = 0;
      const tryAssignTo = (res: ResourceRow): number => {
        for (let idy = 0; idy < monthDays.length; idy++) {
          const fd = monthDays[idy];
          if (!isBetween(fd, forecastStart, forecastEnd)) continue;
          if (!isBetween(fd, res.start, res.end) || !isBetween(fd, p.start, p.end)) continue;
          const ask = quantizeDown(projectPools[p.key].totalRemaining);
          if (ask < QUANTUM) return 0;
          const label = (primary && res.id === primary.id ? "ES1 Standard (primary, full remainder)" : "ES1 Standard (reassigned, full remainder)");
          return assignHours(p, res, fd, ask, label, true);
        }
        return 0;
      };
      if (primary) assigned = tryAssignTo(primary);
      if (assigned <= 0) {
        // least-loaded alt
        const monthResTotals: Dict<number> = {};
        for (let i = 0; i < monthDays.length; i++) {
          const d = monthDays[i], dk = fmtYMD(d);
          const ids = Object.keys(perDayAvail[dk] ?? {});
          for (let j = 0; j < ids.length; j++) {
            const rid = ids[j];
            monthResTotals[rid] = (monthResTotals[rid] ?? 0) + (assignedPerDay[dk]?.[rid] ?? 0);
          }
        }
        const candidates = resources
          .filter(r => anyWorkingDayForResourceInMonth(r, mStart, p))
          .sort((a, b) => (monthResTotals[a.id] ?? 0) - (monthResTotals[b.id] ?? 0));
        for (let i = 0; i < candidates.length; i++) { assigned = tryAssignTo(candidates[i]); if (assigned > 0) break; }
      }
    });
  });

  // Hand off to Part 2 (PSP gating + borrowing + outputs + NEW: Reason pseudo-projects)
  continueAfterMain(
    workbook, config, projects, resources, daysAll,
    perDayAvail, dailySoftCap, projectPools,
    monthAlloc, weekAlloc, resAlloc, proAlloc,
    assignedPerDay, projDayAssigned,
    unavailReasonEvents // NEW
  );
}

/////////////////////// Readers & Writers ///////////////////////

function getTablesByName(workbook: ExcelScript.Workbook): Dict<ExcelScript.Table> {
  const dict: Dict<ExcelScript.Table> = {};
  workbook.getTables().forEach((t) => { dict[t.getName()] = t; });
  return dict;
}
function writeValidationErrors(workbook: ExcelScript.Workbook, errors: string[]): void {
  const ws: ExcelScript.Worksheet = ensureSheet(workbook, "ValidationErrors", true);
  const rows: string[][] = [["Issue"], ...errors.map((e: string): string[] => [e])];
  const range: ExcelScript.Range = ws.getRangeByIndexes(0, 0, rows.length, 1);
  range.setValues(rows);
  const header: ExcelScript.Range = ws.getRangeByIndexes(0, 0, 1, 1);
  formatHeader(header);
  ws.getUsedRange()?.getFormat().autofitColumns();
}
function getBodyRows(t: ExcelScript.Table): Row[] {
  const tblRange = t.getRange();
  const allValues = tblRange.getValues() as Cell[][];
  if (!allValues || allValues.length <= 1) return [];
  const hasTotals = t.getShowTotals();
  const startRow = 1;
  const endRow = allValues.length - (hasTotals ? 1 : 0);
  const body: Row[] = [];
  for (let i = startRow; i < endRow; i++) body.push(allValues[i] as Row);
  return body;
}
function readConfigurations(t: ExcelScript.Table): Config {
  const headers = t.getHeaderRowRange().getValues()[0].map(h => String(h).trim());
  const rows = getBodyRows(t);
  const idx: Dict<number> = {};
  headers.forEach((h, i) => { idx[h] = i; });
  const nameIdx = idx["Name"]; const valIdx = idx["Value"]; const statusIdx = idx["Status"];
  const raw: Dict<string> = {};
  rows.forEach(r => {
    const st = String(r[statusIdx] ?? "").trim();
    if (st && st.toLowerCase() !== "active") return;
    const name = String(r[nameIdx] ?? "").trim();
    const val = String(r[valIdx] ?? "").trim();
    if (name) raw[name] = val;
  });
  const dailyHours = asNumber(raw["Daily Available Hours"] ?? null);
  const forecastStart = asDate(raw["Forecast Start Date"] ?? null);
  const forecastEnd = asDate(raw["Forecast End Date"] ?? null);
  const minMonthlyShare = asNumber(raw["Min Monthly Share Hours Per Project"] ?? null) ?? undefined;
  const minWeeklyShare = asNumber(raw["Min Weekly Share Hours Per Project"] ?? null) ?? undefined;
  const eolWindowDays = asNumber(raw["End-Date Priority Window (days)"] ?? null) ?? undefined;
  const eolMaxBoost = asNumber(raw["End-Date Priority Max Boost"] ?? null) ?? undefined;
  return { dailyHours, forecastStart, forecastEnd, minMonthlyShare, minWeeklyShare, eolWindowDays, eolMaxBoost };
}
function readCalendar(t: ExcelScript.Table, start: Date, end: Date, errors: string[]): Dict<number> {
  const headers = t.getHeaderRowRange().getValues()[0].map(h => String(h).trim());
  const rows = getBodyRows(t);
  const dateIdx = headers.indexOf("Date");
  const availIdx = headers.indexOf("AvailableHours");
  const map: Dict<number> = {};
  rows.forEach(r => {
    const d = asDate(r[dateIdx]);
    const ah = asNumber(r[availIdx]);
    if (!d) { errors.push(`Calendar: invalid Date.`); return; }
    if (ah == null || ah < 0) { errors.push(`Calendar: invalid AvailableHours on ${d}.`); return; }
    if (d.getTime() >= start.getTime() && d.getTime() <= end.getTime()) map[fmtYMD(d)] = ah!;
  });
  return map;
}
function readProjects(t: ExcelScript.Table, fStart: Date, fEnd: Date, errors: string[]): ProjectRow[] {
  const headers = t.getHeaderRowRange().getValues()[0].map(h => String(h).trim());
  const rows = getBodyRows(t);
  const projectKeyIdx = headers.indexOf("ProjectKey");
  const projectIdIdx = headers.indexOf("ProjectId");
  const projectNameIdx = headers.indexOf("ProjectName");
  const descriptionIdx = headers.indexOf("Description");
  const pmIdx = headers.indexOf("Project Manager");
  const totalHoursIdx = headers.indexOf("TotalHours");
  const prevUsedIdx = headers.indexOf("PreviouslyUsedHours");
  const remainingIdx = headers.indexOf("RemainingHours");
  const startIdx = headers.indexOf("StartDate");
  const endIdx = headers.indexOf("EndDate");
  const statusIdx = headers.indexOf("Status");
  const distIdx = headers.indexOf("Distribution Method");
  const primaryResIdIdx = headers.indexOf("PrimaryResourceId");
  const primaryResNameIdx = headers.indexOf("PrimaryResourceName");
  const assignTypeIdx = headers.indexOf("PrimaryResourceAssignmentType");
  const out: ProjectRow[] = [];
  for (let i = 0; i < rows.length; i++) {
    const r = rows[i];
    const item: ProjectRow = {
      key: asString(r[projectKeyIdx]), id: asString(r[projectIdIdx]), name: asString(r[projectNameIdx]),
      desc: asString(r[descriptionIdx]), pm: asString(r[pmIdx]),
      total: asNumber(r[totalHoursIdx]) ?? 0, prevUsed: asNumber(r[prevUsedIdx]) ?? 0, remaining: asNumber(r[remainingIdx]) ?? 0,
      start: asDate(r[startIdx]) ?? new Date("1900-01-01"), end: asDate(r[endIdx]) ?? new Date("9999-12-31"),
      status: (String(r[statusIdx] ?? "").trim() === "Active") ? "Active" : "Inactive",
      distMethod: (String(r[distIdx] ?? "").trim() === "Recurring Monthly") ? "Recurring Monthly" : "Standard",
      primaryId: asString(r[primaryResIdIdx]), primaryName: asString(r[primaryResNameIdx]),
      assignType: ((): AssignType => {
        const v = String(r[assignTypeIdx] ?? "").trim();
        if (v === "Exclusive-ShareOne") return "Exclusive-ShareOne";
        if (v === "Exclusive-DoNotShare") return "Exclusive-DoNotShare";
        return "Primary-ShareProportion";
      })()
    };
    if (!item.key || !item.id) { errors.push(`Projects: missing ProjectKey/ProjectId for row "${item.name}".`); continue; }
    if (item.remaining < 0) { errors.push(`Projects: RemainingHours cannot be negative for ${item.id}.`); continue; }
    if (item.status !== "Active") continue;
    if (!(item.end.getTime() < fStart.getTime() || item.start.getTime() > fEnd.getTime())) out.push(item);
  }
  return out;
}
function readResources(t: ExcelScript.Table, fStart: Date, fEnd: Date, errors: string[]): ResourceRow[] {
  const headers = t.getHeaderRowRange().getValues()[0].map(h => String(h).trim());
  const rows = getBodyRows(t);
  const resIdIdx = headers.indexOf("ResourceId");
  const resNameIdx = headers.indexOf("ResourceName");
  const roleIdx = headers.indexOf("Role");
  const startIdx = headers.indexOf("StartDate");
  const endIdx = headers.indexOf("EndDate");
  const statusIdx = headers.indexOf("Status");
  const out: ResourceRow[] = [];
  for (let i = 0; i < rows.length; i++) {
    const r = rows[i];
    const item: ResourceRow = {
      id: asString(r[resIdIdx]), name: asString(r[resNameIdx]), role: asString(r[roleIdx]),
      start: asDate(r[startIdx]) ?? new Date("1900-01-01"), end: asDate(r[endIdx]) ?? new Date("9999-12-31"),
      status: (String(r[statusIdx] ?? "").trim() === "Active") ? "Active" : "Inactive"
    };
    if (!item.id) { errors.push(`Resources: missing ResourceId for "${item.name}".`); continue; }
    if (item.status !== "Active") continue;
    if (!(item.end.getTime() < fStart.getTime() || item.start.getTime() > fEnd.getTime())) out.push(item);
  }
  resourcesById = {}; for (let i = 0; i < out.length; i++) resourcesById[out[i].id] = out[i];
  return out;
}

// NEW: read unavailability as (1) hours map for capacity math and (2) reason-tagged events for outputs
function readResourceUnavailability(t: ExcelScript.Table): { hours: Dict<number>, byReason: UnavailReasonEvent[] } {
  const headers = t.getHeaderRowRange().getValues()[0].map(h => String(h).trim());
  const rows = getBodyRows(t);
  const resIdIdx = headers.indexOf("ResourceId");
  const dateIdx = headers.indexOf("Date");
  const uaIdx = headers.indexOf("UnavailableHours");
  const reasonIdx = headers.indexOf("Reason");

  const hours: Dict<number> = {};
  const byReason: UnavailReasonEvent[] = [];

  for (let i = 0; i < rows.length; i++) {
    const r = rows[i];
    const rid = asString(r[resIdIdx]);
    const d = asDate(r[dateIdx]);
    const ua = asNumber(r[uaIdx]) ?? 0;
    const reasonRaw = asString(r[reasonIdx]);
    const reason = reasonRaw ? reasonRaw : "Unavailable";

    if (!rid || !d) continue;
    const dk = fmtYMD(d);
    const key = `${rid}|${dk}`;

    // capacity map (sum by resource-date)
    hours[key] = Math.max(0, (hours[key] ?? 0) + Math.max(0, ua));

    // reason events (one row each; skip zero/negative)
    const eff = Math.max(0, ua);
    if (eff > 0) {
      byReason.push({ ResourceId: rid, Date: dk, Hours: eff, Reason: reason });
    }
  }
  return { hours, byReason };
}

function writeTable(workbook: ExcelScript.Workbook, sheetName: string, rows: (string | number)[][]): void {
  safeDeleteSheet(workbook, sheetName);
  const ws = workbook.addWorksheet(sheetName);
  const r = ws.getRangeByIndexes(0, 0, rows.length, rows[0].length);
  r.setValues(rows);
  formatHeader(ws.getRangeByIndexes(0, 0, 1, rows[0].length));
  ws.getUsedRange()?.getFormat().autofitColumns();
}
function cleanupGanttSheets(workbook: ExcelScript.Workbook, baseName: string, keepYears: Set<number>): void {
  const pattern = new RegExp(`^${baseName}_(\\d{4})$`);
  const toDelete: string[] = [];
  const sheets = workbook.getWorksheets();
  for (let i = 0; i < sheets.length; i++) {
    const name = sheets[i].getName();
    const m = name.match(pattern);
    if (!m) continue;
    const y = Number(m[1]);
    if (!keepYears.has(y)) toDelete.push(name);
  }
  for (let i = 0; i < toDelete.length; i++) { const ws = workbook.getWorksheet(toDelete[i]); if (ws) ws.delete(); }
}
function writeProjectGantts(workbook: ExcelScript.Workbook, baseName: string, projects: ProjectRow[], proAlloc: ProAlloc[], start: Date, end: Date): void {
  const firstYear = start.getFullYear();
  const lastYear = end.getFullYear();
  if (lastYear - firstYear > 25) { writeValidationErrors(workbook, [`Gantt year span too large: ${firstYear}..${lastYear}.`]); return; }
  const keepYears = new Set<number>(); for (let y = firstYear; y <= lastYear; y++) keepYears.add(y);
  cleanupGanttSheets(workbook, baseName, keepYears);
  const allocIndex: Dict<Dict<number>> = {};
  for (let i = 0; i < proAlloc.length; i++) {
    const pa = proAlloc[i];
    (allocIndex[pa.ProjectKey] ??= {})[pa.Date] = ((allocIndex[pa.ProjectKey][pa.Date] ?? 0) + pa.Hours);
  }
  for (let year = firstYear; year <= lastYear; year++) {
    const sheetName = `${baseName}_${year}`; safeDeleteSheet(workbook, sheetName);
    const ws = workbook.addWorksheet(sheetName);
    const yStart = (year === firstYear) ? new Date(start.getFullYear(), start.getMonth(), start.getDate()) : new Date(year, 0, 1);
    const yEnd = (year === lastYear) ? new Date(end.getFullYear(), end.getMonth(), end.getDate()) : new Date(year, 11, 31);
    const days = rangeDays(yStart, yEnd);
    if (days.length === 0) { ws.getRange("A1").setValue("No days in this year within forecast."); continue; }
    const headers: string[] = ["ProjectKey", "ProjectId", "ProjectName", ...days.map(d => mmdd(d)), "Total Allocated Hours (Year)"];
    const headerRange = ws.getRangeByIndexes(0, 0, 1, headers.length);
    headerRange.setValues([headers]); formatHeader(headerRange);
    let row = 1;
    for (let ip = 0; ip < projects.length; ip++) {
      const p = projects[ip];
      if (p.end.getFullYear() < year || p.start.getFullYear() > year) continue;
      const line: (string | number)[] = [p.key, p.id, p.name, p.pm];
      let yearSum = 0;
      for (let id = 0; id < days.length; id++) {
        const d = days[id];
        if (!(d.getTime() >= p.start.getTime() && d.getTime() <= p.end.getTime())) { line.push(0); continue; }
        const v = allocIndex[p.key]?.[fmtYMD(d)] ?? 0;
        line.push(v); yearSum += v;
      }
      line.push(yearSum);
      ws.getRangeByIndexes(row, 0, 1, line.length).setValues([line]);
      row++;
    }
    ws.getUsedRange()?.getFormat().autofitColumns();
  }
}
function writeResourceGantts(workbook: ExcelScript.Workbook, baseName: string, resources: ResourceRow[], resAlloc: ResAlloc[], start: Date, end: Date): void {
  const firstYear = start.getFullYear();
  const lastYear = end.getFullYear();
  if (lastYear - firstYear > 25) { writeValidationErrors(workbook, [`Gantt year span too large: ${firstYear}..${lastYear}.`]); return; }
  const keepYears = new Set<number>(); for (let y = firstYear; y <= lastYear; y++) keepYears.add(y);
  cleanupGanttSheets(workbook, baseName, keepYears);
  const hoursIdx: Dict<number> = {};                // ResourceId|ProjectId|ProjectName|YYYY-MM-DD -> hours
  const resCombos: Dict<Set<string>> = {};         // ResourceId -> set "ProjectId|ProjectName"
  for (let i = 0; i < resAlloc.length; i++) {
    const ra = resAlloc[i];
    const dateKey = ra.Date;
    const comboKey = `${ra.ProjectId}|${ra.ProjectName}|${ra.ProjectManager}`;
    const hoursKey = `${ra.ResourceId}|${ra.ProjectId}|${ra.ProjectName}|${dateKey}`;
    hoursIdx[hoursKey] = (hoursIdx[hoursKey] ?? 0) + ra.Hours;
    (resCombos[ra.ResourceId] ??= new Set<string>()).add(comboKey);
  }
  for (let year = firstYear; year <= lastYear; year++) {
    const sheetName = `${baseName}_${year}`; safeDeleteSheet(workbook, sheetName);
    const ws = workbook.addWorksheet(sheetName);
    const yStart = (year === firstYear) ? new Date(start.getFullYear(), start.getMonth(), start.getDate()) : new Date(year, 0, 1);
    const yEnd = (year === lastYear) ? new Date(end.getFullYear(), end.getMonth(), end.getDate()) : new Date(year, 11, 31);
    const days = rangeDays(yStart, yEnd);
    if (days.length === 0) { ws.getRange("A1").setValue("No days in this year within forecast."); continue; }
    const headers: string[] = ["ResourceId", "ResourceName", "ProjectId", "ProjectName", "ProjectManager", ...days.map(d => mmdd(d)), "Total Allocated Hours (Year)"];
    const headerRange = ws.getRangeByIndexes(0, 0, 1, headers.length);
    headerRange.setValues([headers]); formatHeader(headerRange);
    let row = 1;
    for (let ir = 0; ir < resources.length; ir++) {
      const r = resources[ir];
      if (r.end.getFullYear() < year || r.start.getFullYear() > year) continue;
      const combos = Array.from(resCombos[r.id] ?? new Set<string>());
      for (let ic = 0; ic < combos.length; ic++) {
        const [pid, pname, pmanager] = combos[ic].split("|");
        const line: (string | number)[] = [r.id, r.name, pid, pname, pmanager];
        let total = 0;
        for (let id = 0; id < days.length; id++) {
          const dk = fmtYMD(days[id]);
          const key = `${r.id}|${pid}|${pname}|${dk}`;
          const v = hoursIdx[key] ?? 0;
          line.push(v); total += v;
        }
        line.push(total);
        ws.getRangeByIndexes(row, 0, 1, line.length).setValues([line]);
        row++;
      }
    }
    ws.getUsedRange()?.getFormat().autofitColumns();
  }
}
/** Projects in rows; columns are Year / Month / Resource (3 header rows) + GRAND TOTAL row. */
function writeProjectMonthResourceGantt(workbook: ExcelScript.Workbook, sheetName: string, projects: ProjectRow[], resources: ResourceRow[], resAlloc: ResAlloc[], start: Date, end: Date): void {
  safeDeleteSheet(workbook, sheetName);
  const ws = workbook.addWorksheet(sheetName);

  const months: Date[] = (() => {
    const out: Date[] = [];
    let m = new Date(start.getFullYear(), start.getMonth(), 1);
    const e = new Date(end.getFullYear(), end.getMonth(), 1);
    while (m.getTime() <= e.getTime()) { out.push(new Date(m)); m = new Date(m.getFullYear(), m.getMonth() + 1, 1); }
    return out;
  })();

  // Index allocations by (ProjectKey, Month, ResourceId)
  const idx: Dict<number> = {}; // key = ProjectKey|YYYY-MM|ResourceId
  for (let i = 0; i < resAlloc.length; i++) {
    const ra = resAlloc[i];
    const mk = ra.Date.substring(0, 7); // YYYY-MM
    const key = `${ra.ProjectKey}|${mk}|${ra.ResourceId}`;
    idx[key] = (idx[key] ?? 0) + ra.Hours;
  }

  const resIds = resources.map((r: ResourceRow): string => r.id);
  const resNamesById: Dict<string> = {}; resources.forEach((r: ResourceRow): void => { resNamesById[r.id] = r.name; });

  const fixedCols = ["ProjectKey", "ProjectId", "ProjectName", "ProjectManager"];
  const headerRow1: string[] = [...fixedCols];
  const headerRow2: string[] = [...fixedCols];
  const headerRow3: string[] = [...fixedCols];

  for (let im = 0; im < months.length; im++) {
    const m = months[im];
    const y = String(m.getFullYear());
    const mLabel = yyyymm(m);
    for (let ir = 0; ir < resIds.length; ir++) {
      const rid = resIds[ir];
      headerRow1.push(ir === 0 ? y : "");
      headerRow2.push(ir === 0 ? mLabel : "");
      headerRow3.push(resNamesById[rid] ?? rid);
    }
  }

  const totalCols = headerRow3.length;
  const headerRange = ws.getRangeByIndexes(0, 0, 3, totalCols);
  headerRange.setValues([headerRow1, headerRow2, headerRow3]);
  formatHeader(ws.getRangeByIndexes(0, 0, 1, totalCols));
  formatHeader(ws.getRangeByIndexes(1, 0, 1, totalCols));
  formatHeader(ws.getRangeByIndexes(2, 0, 1, totalCols));

  // Prepare running totals per (month x resource) column
  const numBlockCols = months.length * resIds.length;
  const colTotals: number[] = new Array(numBlockCols).fill(0);

  // Rows per project
  let row = 3;
  for (let ip = 0; ip < projects.length; ip++) {
    const p = projects[ip];
    const line: (string | number)[] = [p.key, p.id, p.name, p.pm];

    let c = 0;
    for (let im = 0; im < months.length; im++) {
      const m = months[im];
      const mk = yyyymm(m);
      for (let ir = 0; ir < resIds.length; ir++) {
        const rid = resIds[ir];
        const k = `${p.key}|${mk}|${rid}`;
        const v = idx[k] ?? 0;
        line.push(v);
        colTotals[c] += v;
        c++;
      }
    }

    ws.getRangeByIndexes(row, 0, 1, line.length).setValues([line]);
    row++;
  }

  // GRAND TOTAL row
  const totalsRow: (string | number)[] = ["GRAND TOTAL", "", "", ""];
  for (let i = 0; i < colTotals.length; i++) totalsRow.push(colTotals[i]);
  ws.getRangeByIndexes(row, 0, 1, totalsRow.length).setValues([totalsRow]);
  formatHeader(ws.getRangeByIndexes(row, 0, 1, totalsRow.length));

  ws.getUsedRange()?.getFormat().autofitColumns();
}

/////////////////////// Summary ///////////////////////

function buildProjectSummary(projects: ProjectRow[], resAlloc: ResAlloc[]): (string | number)[][] {
  const utilByProject: Dict<number> = {};
  resAlloc.forEach(ra => { utilByProject[ra.ProjectKey] = (utilByProject[ra.ProjectKey] ?? 0) + ra.Hours; });

  const out: (string | number)[][] = [];
  projects.forEach(p => {
    const allocated = utilByProject[p.key] ?? 0;
    const remainingAtStart = p.remaining;
    const unallocated = Math.max(0, remainingAtStart - allocated);
    out.push([p.key, p.id, p.name, p.desc, p.pm, fmtYMD(p.start), fmtYMD(p.end), p.status, remainingAtStart, allocated, unallocated]);
  });
  return out;
}
/////////////////////// PSP + Borrowing + Outputs (incl. Reason pseudo-projects) ///////////////////////
function continueAfterMain(
  workbook: ExcelScript.Workbook,
  config: Config,
  projects: ProjectRow[],
  resources: ResourceRow[],
  daysAll: Date[],
  perDayAvail: Dict<Dict<number>>,
  dailySoftCap: Dict<Dict<number>>,
  projectPools: Dict<ProjectRemaining>,
  monthAlloc: Dict<Dict<number>>,
  weekAlloc: Dict<Dict<number>>,
  resAlloc: ResAlloc[],
  proAlloc: ProAlloc[],
  assignedPerDay: Dict<Dict<number>>,
  projDayAssigned: Dict<Dict<number>>,
  unavailReasonEvents: UnavailReasonEvent[] // NEW: raw unavailability reason rows
): void {

  // ---------- local helpers (no duplicates) ----------
  const QUANT = QUANTUM;
  const EPSL = EPS;

  const fmtYMD = (d: Date): string =>
    `${d.getFullYear()}-${String(d.getMonth() + 1).padStart(2, "0")}-${String(d.getDate()).padStart(2, "0")}`;
  const monthKey = (d: Date): string =>
    `${d.getFullYear()}-${String(d.getMonth() + 1).padStart(2, "0")}`;
  const weekKey = (d: Date): string => {
    const tmp = new Date(Date.UTC(d.getFullYear(), d.getMonth(), d.getDate()));
    const day = (tmp.getUTCDay() + 6) % 7;
    tmp.setUTCDate(tmp.getUTCDate() - day + 3);
    const wk1 = new Date(Date.UTC(tmp.getUTCFullYear(), 0, 4));
    const week = 1 + Math.round(((tmp.getTime() - wk1.getTime()) / 86400000 - 3) / 7);
    return `${tmp.getUTCFullYear()}-W${String(week).padStart(2, "0")}`;
  };
  const firstOfMonth = (d: Date): Date => new Date(d.getFullYear(), d.getMonth(), 1);
  const lastOfMonth = (d: Date): Date => new Date(d.getFullYear(), d.getMonth() + 1, 0);
  const isBetween = (d: Date, start: Date, end: Date): boolean =>
    d.getTime() >= start.getTime() && d.getTime() <= end.getTime();
  const rangeDays = (start: Date, end: Date): Date[] => {
    const out: Date[] = [];
    const cur = new Date(start.getFullYear(), start.getMonth(), start.getDate());
    while (cur.getTime() <= end.getTime()) { out.push(new Date(cur)); cur.setDate(cur.getDate() + 1); }
    return out;
  };
  const monthsBetween = (aStart: Date, aEnd: Date): Date[] => {
    const out: Date[] = [];
    let m = new Date(aStart.getFullYear(), aStart.getMonth(), 1);
    const e = new Date(aEnd.getFullYear(), aEnd.getMonth(), 1);
    while (m.getTime() <= e.getTime()) { out.push(new Date(m)); m = new Date(m.getFullYear(), m.getMonth() + 1, 1); }
    return out;
  };
  const monthsOverlap = (mStart: Date, pStart: Date, pEnd: Date): boolean => {
    const mEnd = lastOfMonth(mStart);
    return !(mEnd.getTime() < pStart.getTime() || mStart.getTime() > pEnd.getTime());
  };

  const getAssignedMap = (dk: string): Dict<number> => {
    if (!assignedPerDay[dk]) assignedPerDay[dk] = {};
    return assignedPerDay[dk];
  };

  const pushAlloc = (p: ProjectRow, r: ResourceRow, d: Date, grant: number, note: string): void => {
    const dk = fmtYMD(d), mk = monthKey(d), wk = weekKey(d);
    const map = getAssignedMap(dk);
    map[r.id] = (map[r.id] ?? 0) + grant;
    projDayAssigned[p.key][dk] = (projDayAssigned[p.key][dk] ?? 0) + grant;

    resAlloc.push({ ResourceId: r.id, ResourceName: r.name, ProjectKey: p.key, ProjectId: p.id, ProjectName: p.name, Date: dk, Hours: grant, Notes: note });
    proAlloc.push({ ProjectKey: p.key, ProjectId: p.id, ProjectName: p.name, ProjectManager: p.pm, Date: dk, Hours: grant, Notes: note });

    monthAlloc[p.key][mk] = (monthAlloc[p.key][mk] ?? 0) + grant;
    weekAlloc[p.key][wk] = (weekAlloc[p.key][wk] ?? 0) + grant;
  };

  const assignHours = (
    p: ProjectRow,
    r: ResourceRow,
    d: Date,
    hoursRequested: number,
    note: string,
    ignoreSoftCap?: boolean
  ): number => {
    if (hoursRequested <= 0) return 0;

    // EDNS safeguard for Standard borrowing too
    if (p.assignType === "Exclusive-DoNotShare" && r.id !== p.primaryId) return 0;

    const dk = fmtYMD(d), mk = monthKey(d);

    // room on resource-day
    const dayCap = (perDayAvail[dk]?.[r.id] ?? 0);
    const already = getAssignedMap(dk)[r.id] ?? 0;
    let room = Math.max(0, dayCap - already);
    if (room < QUANT) return 0;

    // optional per-day soft cap for the project
    if (!ignoreSoftCap) {
      const cap = dailySoftCap[p.key]?.[dk];
      if (cap !== undefined) {
        const used = projDayAssigned[p.key][dk] ?? 0;
        const leftCap = Math.max(0, cap - used);
        if (leftCap < QUANT) return 0;
        room = Math.min(room, leftCap);
      }
    }

    // pool remaining
    const pools = projectPools[p.key];
    const poolRemain = (p.distMethod === "Recurring Monthly") ? (pools.monthlyRemaining[mk] ?? 0) : pools.totalRemaining;
    if (poolRemain < QUANT) return 0;

    let grant = Math.min(hoursRequested, room, poolRemain);
    grant = Math.floor(grant / QUANT) * QUANT;
    if (grant < QUANT) return 0;

    if (p.distMethod === "Recurring Monthly") projectPools[p.key].monthlyRemaining[mk] = (pools.monthlyRemaining[mk] ?? 0) - grant;
    else projectPools[p.key].totalRemaining = pools.totalRemaining - grant;

    pushAlloc(p, r, d, grant, note);
    return grant;
  };

  // ---- RM usability checks (for gating) ----
  const hasWorkableDay_EDNS = (p: ProjectRow, mStart: Date): boolean => {
    const primary = resources.find(r => r.id === p.primaryId) || null;
    if (!primary) return false;
    const days = rangeDays(firstOfMonth(mStart), lastOfMonth(mStart));
    for (let i = 0; i < days.length; i++) {
      const d = days[i];
      if (!isBetween(d, p.start, p.end) || !isBetween(d, primary.start, primary.end)) continue;
      const dk = fmtYMD(d);
      const room = Math.max(0, (perDayAvail[dk]?.[primary.id] ?? 0) - (getAssignedMap(dk)[primary.id] ?? 0));
      if (room >= QUANT) return true;
    }
    return false;
  };
  const hasWorkableDay_ES1 = (p: ProjectRow, mStart: Date): boolean => {
    if (hasWorkableDay_EDNS(p, mStart)) return true; // primary workable
    const days = rangeDays(firstOfMonth(mStart), lastOfMonth(mStart));
    for (let idy = 0; idy < days.length; idy++) {
      const d = days[idy];
      if (!isBetween(d, p.start, p.end)) continue;
      const dk = fmtYMD(d);
      for (let ir = 0; ir < resources.length; ir++) {
        const r = resources[ir];
        if (!isBetween(d, r.start, r.end)) continue;
        const room = Math.max(0, (perDayAvail[dk]?.[r.id] ?? 0) - (getAssignedMap(dk)[r.id] ?? 0));
        if (room >= QUANT) return true;
      }
    }
    return false;
  };

  const hasRmPoolsLeftThisMonth = (mk: string): boolean => {
    const [yy, mm] = mk.split("-").map(s => Number(s));
    const mStart = new Date(yy, mm - 1, 1);

    for (let ip = 0; ip < projects.length; ip++) {
      const p = projects[ip];
      if (p.distMethod !== "Recurring Monthly") continue;
      if (p.assignType !== "Exclusive-DoNotShare" && p.assignType !== "Exclusive-ShareOne") continue;
      if (!monthsOverlap(mStart, p.start, p.end)) continue;

      const left = projectPools[p.key].monthlyRemaining[mk] ?? 0;
      if (left < QUANT) continue;

      const usable =
        (p.assignType === "Exclusive-DoNotShare")
          ? hasWorkableDay_EDNS(p, mStart)
          : hasWorkableDay_ES1(p, mStart);

      if (usable) return true;
    }
    return false;
  };

  // -------------------------------------------------------------------
  // PSP MONTHLY MAX-OUT (unchanged core)
  // -------------------------------------------------------------------

  const monthsSeq = monthsBetween(config.forecastStart!, config.forecastEnd!);

  // project filters
  const isStd = (p: ProjectRow): boolean => p.distMethod === "Standard";
  const isPSP = (p: ProjectRow): boolean => isStd(p) && p.assignType === "Primary-ShareProportion";
  const isStdNonEDNS = (p: ProjectRow): boolean => isStd(p) && p.assignType !== "Exclusive-DoNotShare";

  // urgency score for ordering (EOL then remaining)
  const urgencyScore = (p: ProjectRow, d: Date): number => {
    const remDays = Math.max(0, Math.floor((p.end.getTime() - d.getTime()) / 86400000));
    const window = config.eolWindowDays ?? 21;
    const maxBoost = config.eolMaxBoost ?? 3;
    const eol = (remDays > window) ? 1 : (1 + (maxBoost - 1) * (window - remDays) / Math.max(1, window));
    const left = projectPools[p.key].totalRemaining;
    return eol * 100000 + left; // coarse tie-breaker by left
  };

  monthsSeq.forEach((mStart): void => {
    const mk = monthKey(mStart);
    if (hasRmPoolsLeftThisMonth(mk)) return; // wait until RM fully consumed OR unusable

    const mEnd = lastOfMonth(mStart);
    const days = rangeDays(mStart, mEnd);

    for (let idy = 0; idy < days.length; idy++) {
      const d = days[idy];
      // Build candidate sets for THIS day only once
      const pspToday = projects.filter(p =>
        isPSP(p) && isBetween(d, p.start, p.end) && (projectPools[p.key].totalRemaining >= QUANT)
      );
      const otherStdToday = projects.filter(p =>
        isStdNonEDNS(p) && isBetween(d, p.start, p.end) && (projectPools[p.key].totalRemaining >= QUANT)
      );

      // sort by urgency (EOL), then remaining
      const sortByUrgencyAndLeft = (a: ProjectRow, b: ProjectRow): number => {
        const ua = urgencyScore(a, d), ub = urgencyScore(b, d);
        return (ub === ua) ? ((projectPools[b.key].totalRemaining - projectPools[a.key].totalRemaining) || 0) : (ub - ua);
      };

      let pspCands = pspToday.slice().sort((a, b) => sortByUrgencyAndLeft(a, b));
      let otherCands = otherStdToday.slice().sort((a, b) => sortByUrgencyAndLeft(a, b));

      // Per-resource greedy fill for the day
      for (let ir = 0; ir < resources.length; ir++) {
        const r = resources[ir];
        if (!isBetween(d, r.start, r.end)) continue;

        const dk = fmtYMD(d);
        let room = Math.max(0, (perDayAvail[dk]?.[r.id] ?? 0) - (getAssignedMap(dk)[r.id] ?? 0));
        room = Math.floor(room / QUANT) * QUANT;
        if (room < QUANT) continue;

        // 1) PSP first (ignore soft caps)
        let iPSP = 0;
        while (room >= QUANT && pspCands.length > 0) {
          const p = pspCands[iPSP % pspCands.length];

          const given = assignHours(p, r, d, QUANT, "PSP Monthly Max-Out", /*ignoreSoftCap*/ true);
          if (given >= QUANT - EPSL) room = Math.floor((room - given) / QUANT) * QUANT;

          // drop exhausted
          pspCands = pspCands.filter(pp => projectPools[pp.key].totalRemaining >= QUANT);
          iPSP++;
        }
        if (room < QUANT) continue;

        // 2) Other Standard (non-EDNS) as secondary fill (ignore soft caps)
        let iO = 0;
        while (room >= QUANT && otherCands.length > 0) {
          const p = otherCands[iO % otherCands.length];

          const given = assignHours(p, r, d, QUANT, "STD Monthly Max-Out", /*ignoreSoftCap*/ true);
          if (given >= QUANT - EPSL) room = Math.floor((room - given) / QUANT) * QUANT;

          otherCands = otherCands.filter(pp => projectPools[pp.key].totalRemaining >= QUANT);
          iO++;
        }
      }
    }
  });

  // ---------------- Daily Borrowing (Standard only) as final safety net ----------------

  type Cand = { p: ProjectRow; left: number; prioKey: [number, number, number, number] };

  const needsMonthlyFloor = (p: ProjectRow, d: Date): boolean => {
    const mk = monthKey(d), got = (monthAlloc[p.key][mk] ?? 0);
    const left = projectPools[p.key].totalRemaining;
    return got + EPSL < (config.minMonthlyShare ?? QUANT) && left >= QUANT;
  };
  const needsWeeklyNudge = (p: ProjectRow, d: Date): boolean => {
    const wk = weekKey(d), got = (weekAlloc[p.key][wk] ?? 0);
    const minW = (config.minWeeklyShare ?? QUANT);
    return (minW > 0) && got + EPSL < minW && (projectPools[p.key].totalRemaining >= QUANT);
  };
  const eolBoostStd = (p: ProjectRow, d: Date): number => {
    const rem = Math.floor((p.end.getTime() - d.getTime()) / 86400000);
    const W = config.eolWindowDays ?? 21;
    const MAX = config.eolMaxBoost ?? 3;
    if (rem > W) return 1;
    const frac = Math.max(0, (W - Math.max(0, rem)) / Math.max(1, W));
    return 1 + (MAX - 1) * frac;
  };

  for (let di = 0; di < daysAll.length; di++) {
    const d = daysAll[di];
    const dk = fmtYMD(d);

    const needy = resources
      .filter(r => isBetween(d, r.start, r.end))
      .map(r => {
        const cap = perDayAvail[dk]?.[r.id] ?? 0;
        const got = getAssignedMap(dk)[r.id] ?? 0;
        return { r, room: Math.max(0, cap - got) };
      })
      .filter(x => x.room >= QUANT)
      .sort((a, b) => b.room - a.room);

    if (needy.length === 0) continue;

    const baseCandidates: Cand[] = projects
      .filter(p => p.distMethod === "Standard" && isBetween(d, p.start, p.end))
      .map((p): Cand => {
        const left = projectPools[p.key].totalRemaining;
        const needMonth = needsMonthlyFloor(p, d) ? 1 : 0;
        const needWeek = needsWeeklyNudge(p, d) ? 1 : 0;
        const boost = eolBoostStd(p, d);
        return { p, left, prioKey: [needMonth, needWeek, boost, left] };
      })
      .filter(c => c.left >= QUANT);

    for (let ni = 0; ni < needy.length; ni++) {
      const need = needy[ni];
      if (need.room < QUANT) continue;

      const sorted = (list: Cand[]): Cand[] =>
        list
          .filter(c => c.p.assignType !== "Exclusive-DoNotShare" && c.left >= QUANT)
          .sort((a, b) => {
            for (let i = 0; i < 4; i++) { if (b.prioKey[i] !== a.prioKey[i]) return b.prioKey[i] - a.prioKey[i]; }
            return 0;
          })
          .map(c => ({ p: c.p, left: c.left, prioKey: c.prioKey }));

      // Round-robin Standard
      let stdCandidates = sorted(baseCandidates);
      let rrRounds = 0;
      const MAX_RR_ROUNDS = 96;
      while (need.room >= QUANT - EPSL && stdCandidates.length > 0 && rrRounds < MAX_RR_ROUNDS) {
        rrRounds++;
        let anyGivenRR = false;
        for (let ci = 0; ci < stdCandidates.length; ci++) {
          if (need.room < QUANT - EPSL) break;
          const cand = stdCandidates[ci];
          if (cand.left < QUANT) continue;

          const parts: string[] = [];
          if (cand.prioKey[0]) parts.push("Monthly-share");
          if (cand.prioKey[1]) parts.push("Weekly-nudge");
          if (cand.prioKey[2] > 1) parts.push("EOL-priority");
          const note = ["Borrowing / RR-Standard", ...parts].join(" / ");

          const given = assignHours(cand.p, need.r, d, QUANT, note);
          if (given >= QUANT - EPSL) {
            cand.left -= given;
            need.room -= given;
            anyGivenRR = true;
          }
        }
        stdCandidates = stdCandidates.filter(c => c.left >= QUANT);
        if (!anyGivenRR) break;
      }

      if (need.room < QUANT - EPSL) continue;

      // Fallback spread
      let candidates = sorted(baseCandidates);
      if (candidates.length === 0) continue;

      const MAX_ROUNDS = 32;
      let rounds = 0;
      while (need.room >= QUANT - EPSL && candidates.length > 0 && rounds < MAX_ROUNDS) {
        rounds++;
        const rawShare = need.room / candidates.length;
        const perShare = Math.max(QUANT, Math.floor(rawShare / QUANT) * QUANT);
        let anyGiven = false;

        for (let ci = 0; ci < candidates.length; ci++) {
          if (need.room < QUANT - EPSL) break;
          const cand = candidates[ci];

          const parts: string[] = [];
          if (cand.prioKey[0]) parts.push("Monthly-share");
          if (cand.prioKey[1]) parts.push("Weekly-nudge");
          if (cand.prioKey[2] > 1) parts.push("EOL-priority");
          const note = ["Borrowing", ...parts].join(" / ");

          const ask = Math.floor(Math.min(perShare, cand.left, need.room) / QUANT) * QUANT;
          if (ask < QUANT) continue;

          const given = assignHours(cand.p, need.r, d, ask, note);
          if (given >= QUANT - EPSL) {
            cand.left -= given;
            need.room -= given;
            anyGiven = true;
          }
        }
        candidates = candidates.filter(c => c.left >= QUANT);

        if (!anyGiven) {
          for (let ci = 0; ci < candidates.length; ci++) {
            if (need.room < QUANT - EPSL) break;
            const cand = candidates[ci];
            const given = assignHours(cand.p, need.r, d, QUANT, "Borrowing / quantum");
            if (given >= QUANT - EPSL) { cand.left -= given; need.room -= given; anyGiven = true; }
          }
          candidates = candidates.filter(c => c.left >= QUANT);
        }
        if (!anyGiven) break;
      }
    }
  }

  // ---------------- NEW: Append Reason-based pseudo-projects to outputs ----------------

  // 1) Build unique reasons and create pseudo-project rows (do NOT affect scheduling/pools)
  const reasonSet = new Set<string>();
  for (let i = 0; i < unavailReasonEvents.length; i++) {
    const r = unavailReasonEvents[i];
    if (r.Hours > 0) reasonSet.add(r.Reason && r.Reason.trim() ? r.Reason.trim() : "Unavailable");
  }

  const reasonProjects: Dict<ProjectRow> = {};
  const reasonToKey = (reason: string): string => {
    // key/id safe-ish but readable; keys do not need Excel sheet safety (columns), just uniqueness
    const trimmed = reason.slice(0, 60);
    return `UA:${trimmed}`;
  };

  // All pseudo-projects share forecast window, zero remaining, Standard, Active
  const fStart = config.forecastStart!;
  const fEnd = config.forecastEnd!;
  reasonSet.forEach((reason) => {
    const key = reasonToKey(reason);
    reasonProjects[reason] = {
      key, id: key, name: reason,
      pm: "System", desc: "Unavailability",
      total: 0, prevUsed: 0, remaining: 0,
      start: fStart, end: fEnd, status: "Active",
      distMethod: "Standard", primaryId: "", primaryName: "", assignType: "Primary-ShareProportion"
    };
  });

  // 2) Convert reason events into allocation rows (use actual resource names where available)
  for (let i = 0; i < unavailReasonEvents.length; i++) {
    const e = unavailReasonEvents[i];
    const hours = Math.max(0, e.Hours);
    if (hours <= 0) continue;

    const reason = e.Reason && e.Reason.trim() ? e.Reason.trim() : "Unavailable";
    const proj = reasonProjects[reason]; if (!proj) continue;

    const rname = (resourcesById[e.ResourceId]?.name ?? e.ResourceId);
    const note = `Unavailability: ${reason}`;

    // Push allocation entries (these do not affect scheduling since done post-run)
    resAlloc.push({
      ResourceId: e.ResourceId, ResourceName: rname,
      ProjectKey: proj.key, ProjectId: proj.id, ProjectName: proj.name,
      Date: e.Date, Hours: hours, Notes: note
    });
    proAlloc.push({
      ProjectKey: proj.key, ProjectId: proj.id, ProjectName: proj.name,
      ProjectManager: proj.pm, Date: e.Date, Hours: hours, Notes: note
    });
  }

  // 3) Extend the project list ONLY for outputs
  const projectsForOutput: ProjectRow[] = projects.concat(Object.values(reasonProjects));

  // ---------------- Outputs (ProjectMonthResource first) ----------------

  const summary = buildProjectSummary(projectsForOutput, resAlloc);

  const pmByKey: Dict<string> = {};
  projectsForOutput.forEach(p => { pmByKey[p.key] = p.pm; });


  // Keep "ProjectMonthResource" as the FIRST output sheet
  writeProjectMonthResourceGantt(
    workbook,
    "ProjectMonthResource",
    projectsForOutput,
    resources,
    resAlloc,
    config.forecastStart!,
    config.forecastEnd!
  );

  writeTable(workbook, "ResourceAllocation", [
    ["ResourceId", "ResourceName", "ProjectKey", "ProjectId", "ProjectName", "Date", "Hours", "Notes"],
    ...resAlloc.map(r => [r.ResourceId, r.ResourceName, r.ProjectKey, r.ProjectId, r.ProjectName, r.Date, r.Hours, r.Notes])
  ]);

  writeTable(workbook, "ResourceAllocation", [
    ["ResourceId", "ResourceName", "ProjectKey", "ProjectId", "ProjectName", "ProjectManager", "Date", "Hours", "Notes"],
    ...resAlloc.map(r => [r.ResourceId, r.ResourceName, r.ProjectKey, r.ProjectId, r.ProjectName, pmByKey[r.ProjectKey] ?? "", r.Date, r.Hours, r.Notes])
  ]);

  writeTable(workbook, "ProjectAllocation", [
    ["ProjectKey", "ProjectId", "ProjectName", "ProjectManager", "Date", "Hours", "Notes"],
    ...proAlloc.map(p => [p.ProjectKey, p.ProjectId, p.ProjectName, p.ProjectManager, p.Date, p.Hours, p.Notes])
  ]);

  writeTable(workbook, "ProjectSummary", [
    ["ProjectKey", "ProjectId", "ProjectName", "Description", "Project Manager", "StartDate", "EndDate", "Status", "Remaining_Hours_At_Start", "Allocated_Hours", "Unallocated_Hours"],
    ...summary
  ]);

  writeProjectGantts(workbook, "ProjectGantt", projectsForOutput, proAlloc, config.forecastStart!, config.forecastEnd!);
  writeResourceGantts(workbook, "ResourceGantt", resources, resAlloc, config.forecastStart!, config.forecastEnd!);
}
